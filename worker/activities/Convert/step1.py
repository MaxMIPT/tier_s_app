from temporalio import activity
from worker.clients.minio_client import minio_client 
from services.minio_service import add_new_file, get_file, delete_file
from activities.Convert import convert


@activity.defn
async def task_1_run_convertation(file_url, workflow_id, client_id) -> str:

    # В РЕДИСЕ НЕТ ТАБЛИЦ, ПРОСТО ОДНА ПОМОЙКА (ШИНА ДАННЫХ) СО СТРУКТУРОЙ:
    # {
    #    workflow_id : uuidv4,
    #    client_id : uuidv4,
    #    task_type: string (в нашем случае audio_conversion)
    #    data: any
    # }

    # 1. Открываем коннект с шиной редиса, получаем все сообщения, ищем наше по workflow_id и task_type
    # если ошибка -> пробрасываем наверх (в флоу) ошибку, по которой флоу завершится досрочно


    # 2. Нужно по api (http) пойти в микросервис конвертации аудио и запустить процесс (получить успех или ошибку (например сервис упал))
    # если ошибка - добавляем сообщение в шину данных (redis) о ошибке и пробрасываем наверх (в флоу) ошибку, по которой флоу завершится досрочно

    # если микросервис отвелил ок:
    # 3. добавляем сообщение в шину данных (redis) о том, что  конвертация аудиофайла началась (ставится соответствующий статус задаче)

    # 4. ЖДЕМ РЕЗУЛЬТАТ ОТ МИКРОСЕРВИСА КОНВЕРТАЦИИ (крутим редис в 1 шаге)
    # если получили сообщение об ошибке конвертации - добавляем сообщение в шину данных (redis) о ошибке и пробрасываем наверх (в флоу) ошибку, по которой флоу завершится досрочно
    # помимо этого нужно удостоверится, что раз в 5 секунд приходит пинг от сервиса конвертации о том, что процесс идет (не завис). Для этого после получения последнего пинга или отправки задачи в микросевис запускаем таймер на 30 секунд, и если он выполнится, пишем сообщение в шину данных о том, что конвертация не удалась, возвращаем во флоу ошибку для прерывания всего процесса. После получения пинга, предыдущий таймер отменяем (чтобы не отменить работающий процесс).

    # -----
    # На этом этапе мы:
    # 1) либо получили из редиса успех о том, что конвертация завершилась успешно
    # 2) либо получили из редиса ответ от микросервиса конвертации, что конвертация не удалась
    # 3) либо выполнился таймаут на зависание и мы также тогда тут считаем, что конвертация не удалась

    # 6. добавляем сообщение в шину данных (redis), что начала конвертация аудиофайла УСПЕШНО ЗАВЕРШЕНА  (ставится соответствующий статус задаче)
    # если успех: В воркфлоу возвращается успех (благодаря этому он понимает что все ок и двигает флоу дальше)
    # если неудача: возвращаем ошибку во флоу


    # 1. upload from_1_path from minio
    old_file = await get_file(minio_client, file_url)

    # 2. run model 1
    ready_file = convert(old_file)

    # 3. upload result of model 1 to minio
    new_file_url = await add_new_file(minio_client, ready_file)    

    # 4. delete previous file
    #await delete_file(old_file)

    # 5. add new file's path to the db


    # 6. add status to redis: task 1 is done


    return new_file_url
    # 7. return new file's path
